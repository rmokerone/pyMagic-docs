按键，回调和中断
====================================
pyMagic板上有三个小按键，从左上角逆时针方向依次为BOOT0, USR, RST按键。
其中RST按键为硬件复位按键, 该按键每次被按下板子就会重启一次，其功能等同于
关闭电源然后再打开。

USR按键为一般应用设计，可以通过Switch对象进行控制。如下代码创建一个
switch对象::

    >>> sw = pyb.Switch()

如果提示有 ``the name pyb does not exist`` 错误，可以通过输入 ``import pyb`` 
进行解决。

可以用如下代码获取Switch对象的状态::

    >>> sw()
    False

如果按键没有被按下，会打印 ``False``, 如果按键被按下会打印 ``True`` 。
尝试用上面的代码获取USR按键按放的状态。(强烈建议自己动手尝试下)

最后的BOOT0按键在进行DFU升级的时候使用，在DFU升级的章节会详细介绍。

Switch 回调
----------------

switch是非常简单的对象，但是其拥有一个非常高级的特性:
``sw.callback()`` 函数。callback()函数用来指定当按键被按下时要运行的函数，
其用到了一个中断。在弄明白中断如何工作之前，最好先来看一个例子。尝试在终端上
运行如下命令::

    >>> sw.callback(lambda:print('press!'))

这行代码表示在每次按键被按下时打印一个 ``press!`` 。在你的电脑上面进行下尝试:
看下当按下USR按键时终端上的输出。
注意：该print会中断任何输入或者任何同步运行的程序。

其它例子如下::

    >>> sw.callback(lambda:pyb.LED(1).toggle())

当每次按键被按下时红色的LED状态将进行翻转。并且当其他代码运行时，该行命令
依然会照常执行。

可以通过传入 ``None`` 参数到回调函数来关闭按键回调::

    >>> sw.callback(None)

除此之外，你也可以传入任何函数名到按键回调函数。在上面的例子中我们使用python的
``lambda`` 特性来创建了一个匿名函数。其等同于如下内容::

    >>> def f():
    ...   pyb.LED(1).toggle()
    ...
    >>> sw.callback(f)

上面的代码创建了一个名称为 ``f`` 的函数，并将其在按键回调函数中注册。
如果你的代码的比 ``lambda`` 允许的要复杂，就可以通过上面的方式来执行。

记住:你的回调函数不能占用任何memory(例如:不能创建tuple或list)。回调函数要尽可能
的简单。如果你需要创建一个list,可以在回调之前进行创建，并将其存储为全局变量(or make
it local and close over it)。如果你需要在回调中做一个资源消耗很大或很长时间的计算。
可以通过在回调函数中设置一个标志位然后在其它地方进行执行。

中断的技术细节
-------------------------------

一步步来探索下按键回调的机制。当你使用 ``sw.callback()`` 来注册一个函数时，
switch对象将与按键相链接的引脚设置为外部中断触发(下降沿)。这时微控制器将监视
该引脚的任意变化，并且如下的事件将会发生。

1. 当按键被按下，引脚电平发生变化(从低电平到高电平), 微控制器将捕获到这个
   改变。
2. 微控制器完成当前正在执行的指令，停止执行指令，并将当前状态进行保存(将各个
   寄存器的数值压入到栈中)。即暂停执行任何代码-正在运行的Python程序。
3. 微控制器开始执行按键外部中断关联的中断handler,中断handler获取你通过
    ``sw.callback()`` 方式注册的函数并执行该函数。
4. 回调函数执行完成，将控制权交给按键中断handler。
5. 按键中断handler返回，微控制器收到中断执行完成的信息。
6. 微控制器恢复第2步中保存的寄存器状态。
7. 继续执行原来运行的程序，除了暂停，程序代码不会意识到其被中断过。

当在同一时间发生了多重中断，事件序列就会变得更复杂一些。对于这种情况，
高优先级的中断先执行，其它按照优先级依次执行。
按键中断的优先级最低。

进一步阅读
---------------

关于硬件中断的更进一步信息可以参见
:ref:`writing interrupt handlers <isr_rules>`.
